<!doctype html>
<html lang="en">
  <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Pinebook Pro OSDev: Hello World</title><link rel="stylesheet" type="text/css"
       href="https://remexre.xyz/css/main.css"><link rel="stylesheet" type="text/css"
       href="https://remexre.xyz/css/monokai-sublime.min.css"><style>article { width: calc(100% - 1.0rem); }</style></head>
  <body>
    <header>
      <a class="subtle" href="https://remexre.xyz/">Home</a>
      <a class="subtle" href="https://remexre.xyz/contact">Contact</a>
      <a class="subtle" href="https://remexre.xyz/projects">Projects</a>
    </header>
    <div class="spacer"></div>
    <article><h1 class="title"><a class="subtle" href="https://remexre.xyz/pbp-osdev/hello-world">Pinebook Pro OSDev: Hello World</a><span class="spacer"></span><span class="meta">2020-02-08</span></h1><p>I recently got a Pinebook Pro, and I want to port <a href="https://remexre.xyz/stahl/dream/#stahlos">StahlOS</a> to it. The journey of a thousand miles begins with a single step, so here's a journal entry on getting a &quot;Hello, world&quot; program running on it.</p>
<h1>The Hardware</h1>
<p>This is written about (and largely on) the ANSI model of the <a href="https://www.pine64.org/pinebook-pro/">Pinebook Pro</a>. Additionally, I use a cable to access the serial port, which wires it up to a 3.5mm headphone jack physical connector. Pine sells a nicely packaged cable, but as people on the forums note (and I've verified), it runs at 5 volts, which causes spooky behavior (up to and including hardware damage) on the Pinebook. Instead, I'm using some jumpers spliced to a headphone cord I cut in half to provide the physical connector to the board.</p>
<p>Initially, I tried <a href="https://www.adafruit.com/product/954">Adafruit's USB to TTL Serial Cable</a>, since I already had it sitting around. However, it turns out it's based on the CP2102 chip, which only supports speeds up to 1Mbps (1000000 baud). The RK3399 (the board inside the Pinebook Pro), however, boots at 1.5Mbps (1500000 baud). Instead, I bought a converter based on the PL2302DX, which can do up to 12Mbps.</p>
<h1>Out of the Box</h1>
<p>The Pinebook Pro ships with an ancient (oldstable?) version of Debian. I ditched it for Manjaro running off an SD card. From the default install, I <code>systemctl disable</code>d lightdm and installed i3 instead. I'm doing most of my usage (including typing this!) from the kernel console in tmux, though.</p>
<p>A hardware switch needs to be flipped inside the device to enable UART2, which provides a serial port over the headphone jack. The <a href="https://wiki.pine64.org/index.php/Pinebook_Pro_Main_Page">Pine wiki</a> documents the location of the switch fairly well; check it for <a href="https://wiki.pine64.org/index.php/Pinebook_Pro_Main_Page#Pinebook_Pro_Internal_Layout">pictures</a>.</p>
<h1>U-Boot</h1>
<p>Once the serial port is connected, rebooting the machine shows the boot logs. Mashing Ctrl-C (or any key on the Manjaro U-Boot, it appears) gets a shell, with vaguely sh-like semantics.</p>
<p>I recommend updating to Manjaro's U-Boot; the U-Boot the Pinebook Pro ships with (as of the January 2020 batch) can't boot from 64-bit ELF files. If your machine boots with an amber power LED instead of a green one, that's a strong indicator you're on the newer Manjaro U-Boot.</p>
<p>The commands in the shell I find most useful are:</p>
<ul>
<li><code>bootelf</code>: Loads the ELF file at the given address, and jumps to its entrypoint.</li>
<li><code>go</code>: Jumps to the given address. Useful when loading raw binaries (not ELFs).</li>
<li><code>load</code>: Loads a file from a filesystem to an arbitrary address.</li>
<li><code>loady</code>: Loads a file over the <a href="https://en.wikipedia.org/wiki/YMODEM">ymodem protocol</a> to an arbitrary address.</li>
<li><code>md</code>: Gives a hexdump of an arbitrary address. Note that it displays in little endian. Also callable as <code>md.b</code>, <code>md.w</code>, <code>md.l</code>, <code>md.q</code> to display with different widths for atoms of data.</li>
</ul>
<h1>Toolchain</h1>
<p>You'll need at least binutils for the <code>aarch64-none-elf</code> target. On Gentoo, this is fairly easy with <a href="https://wiki.gentoo.org/wiki/Crossdev">crossdev</a>. It'll also probably be useful to have your system binutils be built multitarget; this doesn't apply to <code>gas</code>, though, so the <code>aarch64-none-elf</code> versions are still necessary.</p>
<h1>Writing to the UART</h1>
<p>The RK3399's <a href="http://opensource.rock-chips.com/images/e/ee/Rockchip_RK3399TRM_V1.4_Part1-20170408.pdf">Technical Reference Manual</a> is your friend for all of this; it notes that UART2 is mapped to <code>0xff1a0000</code>. There's also some information on how to interface with the chip; if you're familar with programming the <a href="https://en.wikipedia.org/wiki/8250_UART">8250</a> or <a href="https://en.wikipedia.org/wiki/16550_UART">16550</a> UARTs, I believe it's effectively the latter. (Note that unlike how x86 serial ports are typically connected, the UARTs in the Pinebook Pro are all memory-mapped.)</p>
<p>We can write to the UART with an assembly sequence like:</p>
<pre class="hljs"><code class="language-armasm"><span class="hljs-keyword">ldr</span> x0, <span class="hljs-number">=0xff1a0000</span> <span class="hljs-comment">/* Load the x0 register with 0xff1a0000 */</span>
<span class="hljs-keyword">mov</span> x1, <span class="hljs-string">&#x27;!&#x27;</span>         <span class="hljs-comment">/* Load the x1 register with &#x27;!&#x27; (zero-extended) */</span>
<span class="hljs-keyword">strb</span> w1, [x0]       <span class="hljs-comment">/* Store the value in x1 to the address given by x0 */</span>
</code></pre>
<p>This stores the <code>!</code> character in the Transmit Holding Register of the UART. Technically, we need to wait for the Transmit Holding Register Empty Bit of the Line Status Register to be 1. We do this with:</p>
<pre class="hljs"><code class="language-armasm">	<span class="hljs-keyword">ldr</span> x0, <span class="hljs-number">=0xff1a0000</span>
<span class="hljs-symbol">wait_for_tx_ok:</span>
	<span class="hljs-keyword">ldrb</span> w1, [x0, <span class="hljs-number">#0x14</span>]      <span class="hljs-comment">/* Offset the address in x0 by 0x14 */</span>
	tbz w1, <span class="hljs-number">5</span>, wait_for_tx_ok <span class="hljs-comment">/* Loop if bit 5 of x1 is zero */</span>
</code></pre>
<p>Of course, a real OS should use the FIFOs, be interrupt-triggered, and maybe even use DMA. That's outside the scope of this article, but I'll probably touch on it in a future post.</p>
<h1>Putting it All Together</h1>
<p>We can use the above with a bit of glue code to make our &quot;Hello, world&quot; program:</p>
<pre class="hljs"><code class="language-armasm"><span class="hljs-symbol">.section</span> <span class="hljs-meta">.text</span>

<span class="hljs-symbol">.global</span> _start
<span class="hljs-symbol">_start:</span>
	<span class="hljs-keyword">ldr</span> x0, <span class="hljs-number">=0xff1a0000</span>
	<span class="hljs-keyword">ldr</span> x3, <span class="hljs-symbol">=msg</span>
	<span class="hljs-keyword">mov</span> x4, len
	<span class="hljs-keyword">bl</span> write_string     <span class="hljs-comment">/* Call the write_string procedure */</span>
	<span class="hljs-keyword">b</span> .                 <span class="hljs-comment">/* Infinite loop */</span>

<span class="hljs-comment">/** write_string: Writes a string to a UART
 *
 * Input:
 *   x0: UART base address
 *   x3: Address of first character of string
 *   x4: Length of string
 *
 * Side Effects:
 * - Trashes x1, x2, x5
 */</span>
<span class="hljs-symbol">write_string:</span>
	<span class="hljs-keyword">cbz</span> x4, write_string<span class="hljs-meta">.end</span> <span class="hljs-comment">/* If x4 is zero, go to write_string.end */</span>

<span class="hljs-symbol">write_string.wait_for_tx_ok:</span>
	<span class="hljs-keyword">ldrb</span> w1, [x0, <span class="hljs-number">#0x14</span>]
	tbz w1, <span class="hljs-number">5</span>, write_string.wait_for_tx_ok

	<span class="hljs-keyword">ldrb</span> w2, [x3], <span class="hljs-number">#1</span> <span class="hljs-comment">/* After fetching a byte to w2, increment x3 */</span>
	<span class="hljs-keyword">sub</span> x4, x4, <span class="hljs-number">1</span>     <span class="hljs-comment">/* Decrement x4 */</span>
	<span class="hljs-keyword">strb</span> w2, [x0]

	<span class="hljs-keyword">b</span> write_string
<span class="hljs-symbol">write_string.end:</span>
	ret

<span class="hljs-symbol">.section</span> .rodata

<span class="hljs-symbol">msg:</span> .string <span class="hljs-string">&quot;Hello, world!\r\n&quot;</span>
<span class="hljs-symbol">.equ</span> len, . - msg
</code></pre>
<p>We also need a linker script for this:</p>
<pre class="hljs"><code class="language-ld">OUTPUT_FORMAT(elf64-littleaarch64)
ENTRY(_start)

MEMORY {
	kernel : ORIGIN = 0x00280000, LENGTH = 0x00080000
}

SECTIONS {
	.text : {
		. += SIZEOF_HEADERS;
		*(.text)
	} &gt; kernel
	.rodata : { *(.rodata) } &gt; kernel
}
</code></pre>
<p>We compile and link with:</p>
<pre class="hljs"><code class="">aarch64-none-elf-as -o main.o main.s
aarch64-none-elf-ld -o main.elf -T linker.ld main.o -N -z max-page-size=4096
</code></pre>
<h2>Aside: Tricks for a Smaller Executable</h2>
<p>Thanks to <code>clever</code> and <code>doug16k</code> in the <code>#osdev</code> channel on Freenode for showing me a couple of tricks to reduce the size of the ELF file:</p>
<ul>
<li>Adding <code>. += SIZEOF_HEADERS;</code> to the first section, and passing <code>-N</code> to <code>ld</code> lets LD overlap the <code>.text</code> section with the ELF header itself.</li>
<li>Passing <code>-z max-page-size=4096</code> to <code>ld</code> lets it only align the sections to 4k instead of 64k.</li>
</ul>
<p>This brings the binary size down from 66k to 1.3k.</p>
<h1>Hello, world!</h1>
<p>Finally, we're ready to run our program. Connect the Pinebook Pro to your serial port, connect Minicom to the serial port, and boot it. Hit a key to drop to the U-Boot shell, then run <code>loady 0x00880000</code> to start the upload. Hit Ctrl-A, S to open Minicom's &quot;Send files&quot; menu. Once the file is uploaded, run <code>bootelf 0x00880000</code>. If all's gone well, you should see <code>Hello, world!</code> printed, followed by the machine hanging.</p>
<script id="asciicast-297430" src="https://asciinema.org/a/297430.js" async></script><noscript>Click <a href="https://asciinema.org/a/297430">here</a> to view screen recording (powered by asciinema).</noscript>
</article><script src="https://utteranc.es/client.js" repo="remexre/remexre.github.io" issue-number="7" label="comments" theme="github-dark" crossorigin="anonymous" async></script><div class="comments"><noscript><hr>Comments (powered by <a href="https://utteranc.es">utteranc.es</a>) require JavaScript. However, you can comment directly on the <a href="https://github.com/remexre/remexre.github.io/issues/7}">GitHub issue</a> that stores the comments.</noscript></div>
    <div class="spacer"></div>
    <script src="https://remexre.xyz/ext/anchor.min.js"></script><script>const anchors = new AnchorJS();anchors.options.class = "icon subtle";anchors.options.placement = "left";anchors.add("article h1:not(.title), article h2");</script>
  </body>
</html>
