<!doctype html>
<html lang="en">
  <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>G1: The Magic Sets Transformation</title><link rel="stylesheet" type="text/css"
       href="https://remexre.xyz/css/main.css"><link rel="stylesheet" type="text/css"
       href="https://remexre.xyz/css/monokai-sublime.min.css"><style>article { width: calc(100% - 1.0rem); }</style></head>
  <body>
    <header>
      <a class="subtle" href="https://remexre.xyz/">Home</a>
      <a class="subtle" href="https://remexre.xyz/contact">Contact</a>
      <a class="subtle" href="https://remexre.xyz/projects">Projects</a>
    </header>
    <div class="spacer"></div>
    <article><h1 class="title"><a class="subtle" href="https://remexre.xyz/g1/magic-sets">G1: The Magic Sets Transformation</a><span class="spacer"></span><span class="meta">Draft</span></h1><p><em>This post assumes you've read the <a href="https://remexre.xyz/g1/query-lang">previous one in the series</a>.</em></p>
<p>One advantage of Datalog over some other query languages is the ease by which it can be computed incrementally and bottom-up. This allows for a fairly simple async IO implementation of queries with limits; in pseudo-Rust:</p>
<pre class="hljs"><code class="language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> results = QueryResults::new(&amp;query);
<span class="hljs-keyword">let</span> (done_send, done_recv) = oneshot();
read_db_to_stream()
	.take_until(done_recv)
	.for_each(|tuple| {
		results.insert(tuple);
		<span class="hljs-keyword">if</span> results.len() &gt; query.max_results {
			done_send.send(());
		}
	}).<span class="hljs-keyword">await</span>;
</code></pre>
<p>In theory, this results in no IO wasted by continuing to traverse after we have the minimum required to satisfy the query. In practice, this wastes an enormous amount of IO -- it's reading the whole database in, every query! Even if a more efficient means for pulling tuples from disk were used, there would still be computation wasted: tuples are computed without regard to whether they're useful in the producing results.</p>
<p>The Magic Sets transformation works to ensure that only necessary tuples are computed, by creating and using specialized clauses when possible.</p>
<p>For example, take the query:</p>
<pre class="hljs"><code class="language-prolog">friend(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>) :-
	edge(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>, <span class="hljs-string">&quot;friend&quot;</span>).

friendOfFriend(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>) :-
	friend(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">Other</span>),
	friend(<span class="hljs-symbol">Other</span>, <span class="hljs-symbol">You</span>).

sameAtom(<span class="hljs-symbol">X</span>, <span class="hljs-symbol">X</span>) :- atom(<span class="hljs-symbol">X</span>).

frenemyName(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">YourName</span>) :-
	friendOfFriend(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>),
	! friend(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>),
	! sameAtom(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>),
	attr(<span class="hljs-symbol">You</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-symbol">YourName</span>).

?- frenemyName(<span class="hljs-string">&quot;59760f34-eee0-44e2-9358-f48d46c686ee&quot;</span>, <span class="hljs-symbol">YourName</span>).
</code></pre>
<p>This can be optimized to:</p>
<pre class="hljs"><code class="language-prolog">friend(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>) :-
	edge(<span class="hljs-symbol">Me</span>, <span class="hljs-symbol">You</span>, <span class="hljs-string">&quot;friend&quot;</span>).

sameAtom_bb(<span class="hljs-string">&quot;59760f34-eee0-44e2-9358-f48d46c686ee&quot;</span>, <span class="hljs-string">&quot;59760f34-eee0-44e2-9358-f48d46c686ee&quot;</span>) :-
	atom(<span class="hljs-string">&quot;59760f34-eee0-44e2-9358-f48d46c686ee&quot;</span>).

friend_bf(<span class="hljs-symbol">You</span>) :-
	edge(<span class="hljs-string">&quot;59760f34-eee0-44e2-9358-f48d46c686ee&quot;</span>, <span class="hljs-symbol">You</span>, <span class="hljs-string">&quot;friend&quot;</span>).

friendOfFriend_bf(<span class="hljs-symbol">You</span>) :-
	friend_bf(<span class="hljs-symbol">Other</span>),
	friend(<span class="hljs-symbol">Other</span>, <span class="hljs-symbol">You</span>).

frenemyName_bf(<span class="hljs-symbol">YourName</span>) :-
	friendOfFriend_bf(<span class="hljs-symbol">You</span>),
	! friend_bf(<span class="hljs-symbol">You</span>),
	! sameAtom_bb(<span class="hljs-string">&quot;59760f34-eee0-44e2-9358-f48d46c686ee&quot;</span>, <span class="hljs-symbol">You</span>),
	attr(<span class="hljs-symbol">You</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-symbol">YourName</span>).

?- frenemyName_bf(<span class="hljs-symbol">YourName</span>).
</code></pre>
<p>TODO</p>
</article><div class="comments">Comments are not enabled on this post.</div>
    <div class="spacer"></div>
    <script src="https://remexre.xyz/ext/anchor.min.js"></script><script>const anchors = new AnchorJS();anchors.options.class = "icon subtle";anchors.options.placement = "left";anchors.add("article h1:not(.title), article h2");</script>
  </body>
</html>
