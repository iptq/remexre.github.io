<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>remexre.xyz</title>
        <link>https://remexre.xyz/</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://remexre.xyz/tags/silvir/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Sun, 14 Feb 2021 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>SilvIR: Evaluation Semantics, Draft 1</title>
                <pubDate>Sun, 14 Feb 2021 00:00:00 +0000</pubDate>
                <link>https://remexre.xyz/silvir/evaluation-semantics-draft-1/</link>
                <guid>https://remexre.xyz/silvir/evaluation-semantics-draft-1/</guid>
                <description>&lt;p&gt;Birthday post!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;This post assumes you&#x27;ve read the &lt;a href=&quot;https:&#x2F;&#x2F;remexre.xyz&#x2F;silvir&#x2F;definition-draft-1&#x2F;&quot;&gt;previous one in the series&lt;&#x2F;a&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This post might have a higher &amp;quot;difficulty of read to usefulness of reading&amp;quot; ratio than the others in the series...
I&#x27;ll try to precisely specify the evaluation semantics of the IR defined in the previous draft here.
This &lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;module Language.SilvIR&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</description>
            </item>
        
            <item>
                <title>SilvIR: Definition, Draft 1</title>
                <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
                <link>https://remexre.xyz/silvir/definition-draft-1/</link>
                <guid>https://remexre.xyz/silvir/definition-draft-1/</guid>
                <description>&lt;p&gt;&lt;em&gt;This post assumes you&#x27;ve read the &lt;a href=&quot;https:&#x2F;&#x2F;remexre.xyz&#x2F;silvir&#x2F;introduction&#x2F;&quot;&gt;previous one in the series&lt;&#x2F;a&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As covered in the previous post, Silver has a bunch of features that require some trickiness in SilvIR to make implementable.
I&#x27;ll dump the full grammar, then go over it in pieces.&lt;&#x2F;p&gt;
&lt;p&gt;Note that I&#x27;m intending for the actual final grammar to use &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Administrative_Normal_Form&quot;&gt;Administrative Normal Form&lt;&#x2F;a&gt; as a way to make the evaluation order explicit, and make writing correct optimizations easier.
However, this definition doesn&#x27;t contain that, for simplicity&#x27;s sake.
Next post does, but I&#x27;ll try and ease into it.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#272822;&quot;&gt;
&lt;span style=&quot;color:#f8f8f2;&quot;&gt;Literal ::= Int
         |  String

PrimPattern ::= varPat(LocalName)
             |  litPat(Literal)
             |  anyPat

Pattern ::= recordPat(Map&amp;lt;String, PrimPattern&amp;gt;)
         |  treeOrTermPat(ProdName, List&amp;lt;PrimPattern&amp;gt;)
         |  primPat(PrimPattern)

IsChildDecorable ::= childIsDecorable
                  |  childIsntDecorable

Expr ::= local(LocalName)
      |  global(GlobalName)
      |  lit(Literal)
      |  let(LocalName, Expr, Expr)
      |  letrec(Map&amp;lt;LocalName, Expr&amp;gt;, Expr)
      |  lam(List&amp;lt;LocalName&amp;gt;, Expr)
      |  call(Expr, List&amp;lt;Expr&amp;gt;)
      |  error(Expr)
      |  thunk(Expr)
      |  force(Expr)
      |  case(Expr, List&amp;lt;Pair&amp;lt;Pattern, Expr&amp;gt;&amp;gt;)
      |  pureForeign(String, List&amp;lt;Expr&amp;gt;)
      |  impureForeign(String, List&amp;lt;Expr&amp;gt;)
      |  makeRecord(Map&amp;lt;String, Expr&amp;gt;)
      |  getRecordMember(String, Expr)
      |  cons(ProdName, List&amp;lt;Pair&amp;lt;IsChildDecorable, Expr&amp;gt;&amp;gt;)
      |  getChild(Nat, Expr)
      |  getAttr(AttrName, Expr)
      |  setAttr(AttrName, Expr, Expr, Expr)
      |  combineAttr(AttrName, Expr, Expr, Expr, Expr)
      |  copyTree(Expr)
      |  decorate(Expr, Map&amp;lt;AttrName, Expr&amp;gt;)
      |  undecorate(Expr)

Priority ::= Int

TopLevelItem ::= globalDecl(GlobalName, Expr)
              |  prodDecl(ProdName, NTName)
	      |  defaultProdBodyDecl(NTName, Priority, LocalName, Expr)
	      |  prodBodyDecl(ProdName, Priority, LocalName, Expr)

Program ::= Set&amp;lt;TopLevelItem&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;literals&quot;&gt;&lt;code&gt;Literal&lt;&#x2F;code&gt;s&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#272822;&quot;&gt;
&lt;span style=&quot;color:#f8f8f2;&quot;&gt;Literal ::= Int
         |  String
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Literals are used in a few places in the grammar; they are a subset of the runtime values that exist.
Runtime values also include functions (which are constructed with &lt;code&gt;lam&lt;&#x2F;code&gt;), thunks (which are constructed with &lt;code&gt;thunk&lt;&#x2F;code&gt;), records (which are constructed with &lt;code&gt;makeRecord&lt;&#x2F;code&gt;), terms (which are constructed with &lt;code&gt;cons&lt;&#x2F;code&gt;), and trees (which are constructed with &lt;code&gt;decorate&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;patterns&quot;&gt;&lt;code&gt;Pattern&lt;&#x2F;code&gt;s&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#272822;&quot;&gt;
&lt;span style=&quot;color:#f8f8f2;&quot;&gt;PrimPattern ::= varPat(LocalName)
             |  litPat(Literal)
             |  anyPat

Pattern ::= recordPat(Map&amp;lt;String, PrimPattern&amp;gt;)
         |  treeOrTermPat(ProdName, List&amp;lt;PrimPattern&amp;gt;)
         |  primPat(PrimPattern)
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Patterns in SilvIR are restricted to &amp;quot;simple patterns,&amp;quot; which disallow nested patterns.
SilvIR patterns also do &lt;em&gt;not&lt;&#x2F;em&gt; interact with forwarding in any way; there will be later discussion on this.&lt;&#x2F;p&gt;
&lt;p&gt;Note that &lt;code&gt;recordPat&lt;&#x2F;code&gt; implements a &amp;quot;subset match&amp;quot;; fields not present in the pattern are ignored.
As an example, the following expression evaluates to &lt;code&gt;1&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#272822;&quot;&gt;
&lt;span style=&quot;color:#f8f8f2;&quot;&gt;case(makeRecord({ &amp;quot;a&amp;quot; = lit(1), &amp;quot;b&amp;quot; = lit(2) }),
  [ (recordPat({ &amp;quot;a&amp;quot; = varPat(&amp;quot;x&amp;quot;) }), local(&amp;quot;x&amp;quot;))
  , (anyPat, lit(3))
  ])
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Everything else in patterns should have fairly intuitive semantics.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;exprs-and-toplevelitems-the-fp-looking-parts&quot;&gt;&lt;code&gt;Expr&lt;&#x2F;code&gt;s and &lt;code&gt;TopLevelItem&lt;&#x2F;code&gt;s, the FP-looking parts&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#272822;&quot;&gt;
&lt;span style=&quot;color:#f8f8f2;&quot;&gt;Expr ::= local(LocalName)
      |  global(GlobalName)
      |  lit(Literal)
      |  let(LocalName, Expr, Expr)
      |  letrec(Map&amp;lt;LocalName, Expr&amp;gt;, Expr)
      |  lam(List&amp;lt;LocalName&amp;gt;, Expr)
      |  call(Expr, List&amp;lt;Expr&amp;gt;)
      |  error(Expr)
      |  thunk(Expr)
      |  force(Expr)
      |  case(Expr, List&amp;lt;Pair&amp;lt;Pattern, Expr&amp;gt;&amp;gt;)
      |  pureForeign(String, List&amp;lt;Expr&amp;gt;)
      |  impureForeign(String, List&amp;lt;Expr&amp;gt;)
      |  makeRecord(Map&amp;lt;String, Expr&amp;gt;)
      |  getRecordMember(String, Expr)
      |  ...

TopLevelItem ::= globalDecl(GlobalName, Expr)
              |  ...

Program ::= Set&amp;lt;TopLevelItem&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Most of what appears here should look &amp;quot;fairly normal&amp;quot; for a dynamically-typed, call-by-value, functional language with multi-argument functions and optional laziness.
(Well, I guess I said &amp;quot;tastes like Scheme&amp;quot; in more words...)&lt;&#x2F;p&gt;
&lt;p&gt;SilvIR is a call-by-value language, but supports thunks as a built-in type in order to support Silver&#x27;s demand-driven attribute evaluation strategy.
Thunks are created with the &lt;code&gt;thunk&lt;&#x2F;code&gt; AST node, but also result from using &lt;code&gt;global&lt;&#x2F;code&gt; to access global variables, and &lt;code&gt;local&lt;&#x2F;code&gt; to access variables bound by a &lt;code&gt;letrec&lt;&#x2F;code&gt;.
This is because laziness is also used to implement circular&#x2F;recursive values, which one can create with both global bindings and letrec-created bindings.&lt;&#x2F;p&gt;
&lt;p&gt;Calls to foreign functions are split into &amp;quot;pure&amp;quot; and &amp;quot;impure&amp;quot; versions.
Essentially, a call is considered pure if there is no non-UB way for the function to exhibit side effects, &lt;em&gt;including non-termination&lt;&#x2F;em&gt;.
This gives the optimizer leeway to aggressively transform, duplicate, or eliminate calls to these functions.
Examples of pure foreign functions are arithmetic operators on integers, string concatenation, and &lt;code&gt;reflect&lt;&#x2F;code&gt;.
Examples of impure foreign functions are &lt;code&gt;genInt&lt;&#x2F;code&gt; and &lt;code&gt;error&lt;&#x2F;code&gt; (though, &lt;code&gt;error&lt;&#x2F;code&gt; has its own AST node to facilitate debugger integration).&lt;&#x2F;p&gt;
&lt;p&gt;At program startup, a global environment is established from the top-level items.
The expression &lt;code&gt;call(force(global(&amp;quot;main&amp;quot;)))&lt;&#x2F;code&gt; is then evaluated.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;exprs-and-toplevelitems-the-attribute-grammar-specific-parts&quot;&gt;&lt;code&gt;Expr&lt;&#x2F;code&gt;s and &lt;code&gt;TopLevelItem&lt;&#x2F;code&gt;s, the attribute-grammar-specific parts&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#272822;&quot;&gt;
&lt;span style=&quot;color:#f8f8f2;&quot;&gt;Expr ::= ...
      |  cons(ProdName, List&amp;lt;Pair&amp;lt;IsChildDecorable, Expr&amp;gt;&amp;gt;)
      |  getChild(Nat, Expr)
      |  getAttr(AttrName, Expr)
      |  setAttr(AttrName, Expr, Expr, Expr)
      |  combineAttr(AttrName, Expr, Expr, Expr, Expr)
      |  copyTree(Expr)
      |  decorate(Expr, Map&amp;lt;AttrName, Expr&amp;gt;)
      |  undecorate(Expr)

IsChildDecorable ::= childIsDecorable
                  |  childIsntDecorable

TopLevelItem ::= ...
              |  prodDecl(ProdName, NTName)
	      |  defaultProdBodyDecl(NTName, Priority, LocalName, Expr)
	      |  prodBodyDecl(ProdName, Priority, LocalName, Expr)

Priority ::= Int
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The attribute-grammar-specific parts of SilvIR are the complicated part with potentially-controversial semantics, so this might be unclear.&lt;&#x2F;p&gt;
&lt;p&gt;We refer to data values that immediately result from applying a constructor to arguments as terms (often as &lt;strong&gt;undecorated terms&lt;&#x2F;strong&gt; for clarity).
We call the results of the process in which inherited attributes are applied and attribute thunks are created trees (often as &lt;strong&gt;decorated trees&lt;&#x2F;strong&gt; for clarity).&lt;&#x2F;p&gt;
&lt;p&gt;Undecorated terms can be constructed with the &lt;code&gt;cons&lt;&#x2F;code&gt; expression.
It takes the name of the production the value belongs to (sometimes referred to as the tag) and a list of arguments, as well as a flag describing whether the child is decorable.
This flag (formerly, misleadingly, known as &lt;code&gt;IsChildDeclaredDecorated&lt;&#x2F;code&gt;) determines whether the child will be traversed at tree-construction time.
This is effectively a single bit of type information; in the future, SilvIR may be changed to provide this information via &lt;code&gt;prodDecl&lt;&#x2F;code&gt; instead.&lt;&#x2F;p&gt;
&lt;p&gt;Most children of nonterminal type should be declared &lt;code&gt;childIsDecorable&lt;&#x2F;code&gt;.
Examples of types for which this should be &lt;code&gt;childIsntDecorable&lt;&#x2F;code&gt; are &lt;code&gt;Integer&lt;&#x2F;code&gt; (since integers aren&#x27;t nonterminal types), &lt;code&gt;Decorated Foo&lt;&#x2F;code&gt; (since references to other trees shouldn&#x27;t be redecorated), and skolem variables (since these may be instantiated to one of the former).
If the exact semantics of this are unclear, they should hopefully become more clear later, when the execution semantics are gone over.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;getChild&lt;&#x2F;code&gt; simply reads a child from a term or tree.
It&#x27;s UB to read a child that doesn&#x27;t exist, etc, etc.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;getAttr&lt;&#x2F;code&gt; reads an attribute off of a tree.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;setAttr&lt;&#x2F;code&gt; and &lt;code&gt;combineAttr&lt;&#x2F;code&gt; are used at tree-construction time to write attributes to a tree.
&lt;code&gt;setAttr(attr, tree, value, next)&lt;&#x2F;code&gt; evaluates to the same value &lt;code&gt;next&lt;&#x2F;code&gt; evaluates to, after performing the side effect of setting the attribute &lt;code&gt;attr&lt;&#x2F;code&gt; on the tree &lt;code&gt;tree&lt;&#x2F;code&gt; to the value that results from evaluating &lt;code&gt;value&lt;&#x2F;code&gt;.
This possibly replaces a previous value of the attribute.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;combineAttr(attr, tree, value, func, next)&lt;&#x2F;code&gt; is similar, and is used to implement collection attributes.
If &lt;code&gt;attr&lt;&#x2F;code&gt; was already set on &lt;code&gt;tree&lt;&#x2F;code&gt;, it sets it to the result of evaluating &lt;code&gt;call(func, getAttr(attr, tree), value)&lt;&#x2F;code&gt;.
If &lt;code&gt;attr&lt;&#x2F;code&gt; was not already set on &lt;code&gt;tree&lt;&#x2F;code&gt;, it sets it to the result of evaluating &lt;code&gt;value&lt;&#x2F;code&gt;.
This whole &lt;code&gt;combineAttr&lt;&#x2F;code&gt; expression then evalutes to the result of evaluating &lt;code&gt;next&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;copyTree&lt;&#x2F;code&gt; simply copies a tree, so mutations can be made on it without disturbing the original.
This copy is deep in the decorable-term-structure of the tree, but shallow in the attributes and in the non-decorable-children.
(This isn&#x27;t needed by current Silver semantics, but will come in handy for Lucas&#x27; redecoration work, and is easy.)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;undecorate&lt;&#x2F;code&gt; returns a copy of a tree as a term, stripping off all attributes on decorable children.
This copy is deep in the decorable-term-structure of the tree, but shallow in the non-decorable-children.&lt;&#x2F;p&gt;
&lt;p&gt;All these pieces come together with &lt;code&gt;decorate&lt;&#x2F;code&gt;.
&lt;code&gt;decorate&lt;&#x2F;code&gt;&#x27;s first argument is a term to perform tree-construction on.
First, a tree is allocated, mirroring the structure of the term, replacing decorable children with freshly allocated trees.
Then, tree-construction proceeds; for each node:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Collect the production bodies that apply to this term, and sort them by priority, low to high.
This is every &lt;code&gt;prodBodyDecl&lt;&#x2F;code&gt; that has the same &lt;code&gt;ProdName&lt;&#x2F;code&gt; as the term, as well as every &lt;code&gt;defaultProdBodyDecl&lt;&#x2F;code&gt; that has the same &lt;code&gt;NTName&lt;&#x2F;code&gt; as the one associated to the term by the &lt;code&gt;prodDecl&lt;&#x2F;code&gt; that declared the production.&lt;&#x2F;li&gt;
&lt;li&gt;Run every production body that has a negative priority in a priority-respecting order.
Production bodies should be structured essentially as the identity function, but with side effects via &lt;code&gt;setAttr&lt;&#x2F;code&gt; and &lt;code&gt;combineAttr&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Run this process for each decorable child, from lowest index to highest.&lt;&#x2F;li&gt;
&lt;li&gt;Run every production body that has a non-negative priority in a priority-respecting order.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Priorities allow for default productions and the various automatic attributes to be implemented correctly, and negative priorities allow for the optimization where inherited attributes are passed down strictly, avoiding a traversal back up the tree when they&#x27;re demanded.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;remarks&quot;&gt;Remarks&lt;&#x2F;h2&gt;
&lt;p&gt;For a worked-through example of a simple grammar translated to (a very slightly older version of) this IR and run, see &lt;a href=&quot;https:&#x2F;&#x2F;remexre.xyz&#x2F;silvir&#x2F;arithmetic-example.html&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Annotations aren&#x27;t covered here; I think they can be transformed to children?
In the next post, we&#x27;ll look at the execution semantics of this IR in more depth.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>SilvIR: Introduction</title>
                <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate>
                <link>https://remexre.xyz/silvir/introduction/</link>
                <guid>https://remexre.xyz/silvir/introduction/</guid>
                <description>&lt;p&gt;I&#x27;m planning to work on an IR for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;melt-umn&#x2F;silver&quot;&gt;Silver&lt;&#x2F;a&gt;, an attribute-grammar based language for compiler construction.
This&#x27;ll probably form the core of my MS thesis work, so my advisor recommended I blog about it as a way to communicate everything properly to the rest of the group, with the side benefits of getting a head start on laying everything out for writing the actual thesis.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;background&quot;&gt;Background&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;em&gt;(If you&#x27;re a MELT group member I&#x27;m making read this, feel free to skip this section.)&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Attribute grammars are a formalism for describing computations on trees.
The core idea is that you describe the syntax (concrete or abstract) of your language with a grammar, and then can perform transformations on it by describing them in terms of attributes.&lt;&#x2F;p&gt;
&lt;p&gt;Generally, attributes can be divided into two classes, &lt;em&gt;inherited&lt;&#x2F;em&gt; and &lt;em&gt;synthesized&lt;&#x2F;em&gt;.
Inherited attributes (informally, inhs) are passed from the parent node down to its children.
Synthesized attributes (informally, syns) are computed from inherited attributes and children, and typically are passed from children up to their parents.&lt;&#x2F;p&gt;
&lt;p&gt;Typical examples of inherited attributes include the environment and other information about the context of a term.
Typical examples of synthesized attributes include the type of a term, the errors present on a term and its subterms, and the translation of a term to an IR or target language.&lt;&#x2F;p&gt;
&lt;p&gt;Silver implements one particular evaluation strategy for attribute grammars, demand-driven evaluation.
This looks approximately like a lazy functional language, and many idioms are shared between Haskell and Silver as a result.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;&#x2F;h1&gt;
&lt;p&gt;Silver is super convenient to use for writing compilers with, but its performance is a lot worse than I wish it was.
Furthermore, lots of optimizations that would be really nice to have implemented are pretty dang tricky.
This is mostly for historical reasons relating to the implementation of Silver, rather than its properties or expressiveness as a language -- Silver best-practices didn&#x27;t exist when Silver was written, so it doesn&#x27;t follow them.&lt;&#x2F;p&gt;
&lt;p&gt;Currently, Silver compiles directly (i.e., without an IR!) to a huge amount of Java source code, which is unideal from an aesthetic perspective, and makes implementing additional passes pretty tricky.&lt;&#x2F;p&gt;
&lt;p&gt;The big goals of SilvIR as an IR for Silver are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;To make experimenting with different translations easier (eg. &amp;quot;can we do aggressive stack allocation &lt;em&gt;a la&lt;&#x2F;em&gt; Go to reduce GC pressure?&amp;quot; &amp;quot;would &lt;a href=&quot;https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2020&#x2F;11&#x2F;perceus-tr-v1.pdf&quot;&gt;Perceus&lt;&#x2F;a&gt; result in measurable speedups?&amp;quot;)&lt;&#x2F;li&gt;
&lt;li&gt;To implement &amp;quot;linking,&amp;quot; which should drastically reduce startup time versus the Java translation&lt;&#x2F;li&gt;
&lt;li&gt;To make writing relatively low-level optimization passes (eg. and esp. strictness analysis) easier&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Initially I plan to compile Silver to SilvIR, and write an interpreter for SilvIR with the &lt;a href=&quot;https:&#x2F;&#x2F;www.graalvm.org&#x2F;graalvm-as-a-platform&#x2F;language-implementation-framework&#x2F;&quot;&gt;Truffle Language Implementation Framework&lt;&#x2F;a&gt; in order to get access to a fast runtime and high-throughput GC easily.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, as &amp;quot;stretch goals,&amp;quot; it&#x27;d be kinda nice to have:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A real profiler that can map hotspots to source language positions (via &lt;a href=&quot;https:&#x2F;&#x2F;visualvm.github.io&#x2F;graal.html&quot;&gt;VisualVM&#x27;s GraalVM support&lt;&#x2F;a&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;A real debugger (via &lt;a href=&quot;https:&#x2F;&#x2F;www.graalvm.org&#x2F;tools&#x2F;chrome-debugger&#x2F;&quot;&gt;GraalVM&#x27;s Chrome DevTools Protocol support&lt;&#x2F;a&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.graalvm.org&#x2F;tools&#x2F;code-coverage&#x2F;&quot;&gt;Code coverage checking&lt;&#x2F;a&gt; for seeing what dark corners of the compiler are never exercised (and for test coverage purposes in general)&lt;&#x2F;li&gt;
&lt;li&gt;A JavaScript or WASM backend, as a step towards being able to do a non-cursed &amp;quot;try Silver in the browser&amp;quot; thing&lt;&#x2F;li&gt;
&lt;li&gt;A formal semantics of SilvIR in Coq or Lean, to talk about the correctness of optimizations and backends&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;design-considerations&quot;&gt;Design Considerations&lt;&#x2F;h1&gt;
&lt;p&gt;Silver supports a large number of extensions to the basic idea of attribute grammars, and supporting all of them is necessarily a goal.
Notable extensions include:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;concepts&#x2F;aspects&#x2F;&quot;&gt;Aspect productions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;concepts&#x2F;automatic-attributes&#x2F;&quot;&gt;Automatic attributes&lt;&#x2F;a&gt;, including functor and monoid attributes.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;concepts&#x2F;collections&#x2F;&quot;&gt;Collection attributes&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;ref&#x2F;stmt&#x2F;forwarding&#x2F;&quot;&gt;Forwarding&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;concepts&#x2F;decorated-vs-undecorated&#x2F;#higher-order-undecorated&quot;&gt;Higher-order attributes&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;ref&#x2F;expr&#x2F;pattern-matching&#x2F;&quot;&gt;Pattern matching&lt;&#x2F;a&gt;, which has some &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;melt-umn&#x2F;silver&#x2F;issues&#x2F;387&quot;&gt;unusual consequences&lt;&#x2F;a&gt; when combined with forwarding (&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;concepts&#x2F;interference&#x2F;#patterns-arent-exceptions&quot;&gt;though you shouldn&#x27;t do this anyway&lt;&#x2F;a&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;silver&#x2F;concepts&#x2F;decorated-vs-undecorated&#x2F;#reference-decorated&quot;&gt;Reference attributes&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;All of these are used within the implementation of Silver, so must be supported before Silver can be bootstrapped on SilvIR.
In the &lt;a href=&quot;https:&#x2F;&#x2F;remexre.xyz&#x2F;silvir&#x2F;definition-draft-1&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt;, we&#x27;ll look at (the current draft of) the actual definition of the IR.&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
